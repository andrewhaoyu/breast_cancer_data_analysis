return("Npml")
}
}
#compare the relative mse of the three different methods
RelativeMeanFunction <- function(x) {
places <- 2
temp <- 100*x[4,4]/x[4,3]
return(round(temp,places))
}
RelativeLogitFunction <- function(x) {
places <- 2
temp <- 100*x[12,4]/x[12,3]
return(round(temp,places))
}
#Caculate the standard devivation of the simulation bias
SimulationSdBiasMean <- function(R,x) {
places <- 4
return(round(sqrt(x[3,4]/R),places))
}
SimulationSdBiasLogit <- function(R,x) {
places <- 4
return(round(sqrt(x[11,4]/R),places))
}
# calculate three methods results -----------------------------------------------
#setting of the true parameters:
# Theta.Bar.Vector(mean),M.Vector(precision),K.Vector(sample size) R(replicates)
# Theta.Low and Theta.High are the boundaries of theta,
# if theta is less than Theta.Low, then theta equals Theta.Low; same case for Theta.High
Theta.Bar.Vector <- c(0.1)
M.Vector <- c(0.05,0.25,0.5,1,1.5,2,5,10,25,10000)
K.Vector <- c(10,20,50,75,100,150)
Theta.Low <- 0.005
Theta.High <- 0.995
for(i1 in 1:length(Theta.Bar.Vector)) {
for(i2 in 1:length(M.Vector)) {
for(i3 in 1:length(K.Vector)) {
places <- 5
R <- 10
#get alpha and beta from tehta_bar and M
Theta.Bar <- Theta.Bar.Vector[i1]
M <- M.Vector[i2]
alpha <- Theta.Bar*M
beta <- M*(1-Theta.Bar)
K <- K.Vector[i3]
#choose the 1:K/(K+1) quantile of beta distribution
cuts <- 1:K/(K+1)
theta <- qbeta(cuts,alpha,beta)
theta[which(theta<Theta.Low)] <- Theta.Low
theta[which(theta>Theta.High)] <- Theta.High
#calculate the true results of theta mean, theta recip and theta logit
True.Theta.Mean <- mean(theta)
True.Theta.Recip <- mean(1/theta)
True.Theta.Logit <- mean(logit(theta))
True.Theta.Var <- var(theta)*(K-1)/K
True.Theta.Recip.Var <- var(1/theta)*(K-1)/K
True.Theta.Logit.Var <- var(logit(theta))*(K-1)/K
#get the esimate of the three different methods
Stratified.Estimate.Results <- NULL
Pooled.Estimate.Results <- NULL
Npml.Estimate.UU <- NULL
Npml.Estimate.pp <- NULL
Para.Beta.Estimate.Result <- NULL
NTL <- sapply(theta,function(x) (rgeom(R,x)+1)) #generate the total N for all R replicates
for(ind in 1:R){
N <- NTL[ind,]
#apply the three method function to the data
Para.Beta.Estimate.Result <- c(Para.Beta.Estimate.Result,ParaBetaEstimateFunction(N))
Stratified.Estimate.Results <- c(Stratified.Estimate.Results,StratEstimateFunction(N,c(1:K)))
Pooled.Estimate.Results <- c(Pooled.Estimate.Results,PooledEstimateFunction(N,c(1:K)))
temp <- NPMLEstimateFunction(N,c(1:K))
Npml.Estimate.UU <- cbind(Npml.Estimate.UU,temp[[1]])
Npml.Estimate.pp <- cbind(Npml.Estimate.pp,temp[[2]])
}
#caculate the mean estimate of the three different methods
#caculate the bias and variance of the mean estimate and get the mse
Stratified.Estimate.Bias <- mean(Stratified.Estimate.Results)-True.Theta.Mean
Stratified.Estimate.Var <- var(Stratified.Estimate.Results)
Stratified.Estimate.Mse <- Stratified.Estimate.Bias^2+Stratified.Estimate.Var
Pooled.Estimate.Bias <- mean(Pooled.Estimate.Results)-True.Theta.Mean
Pooled.Estimate.Var <- var(Pooled.Estimate.Results)
Poole.Estimate.Mse <- Pooled.Estimate.Bias^2+Pooled.Estimate.Var
Npml.Estimate.Results <- apply(Npml.Estimate.pp*Npml.Estimate.UU,2,sum)
Npml.Estimate.Bias <- mean(Npml.Estimate.Results)-True.Theta.Mean
Npml.Estimate.Var <- var(Npml.Estimate.Results)
Npml.Estimate.Mse <- Npml.Estimate.Bias^2+Npml.Estimate.Var
Result.Mean <- list(True.Theta.Mean=round(True.Theta.Mean,places),True.Theta.Var=round(True.Theta.Var,places),Stratified.Estimate.Bias=round(Stratified.Estimate.Bias,places),Stratified.Estimate.Var=round(Stratified.Estimate.Var,places),Stratified.Estimate.Mse=round(Stratified.Estimate.Mse,places),Pooled.Estimate.Bias=round(Pooled.Estimate.Bias,places),Pooled.Estimate.Var=round(Pooled.Estimate.Var,places),Poole.Estimate.Mse=round(Poole.Estimate.Mse,places),Npml.Estimate.Bias=round(Npml.Estimate.Bias,places),Npml.Estimate.Var=round(Npml.Estimate.Var,places),Npml.Estimate.Mse=round(Npml.Estimate.Mse,places))
#caculate the recip estimate of the three defferent methods
#caculate the bias and variance of the recip estimate and get the mse
Stratified.Estimate.Recip.Bias <- mean(1/Stratified.Estimate.Results)-True.Theta.Recip
Stratified.Estimate.Recip.Var <- var(1/Stratified.Estimate.Results)
Stratified.Estimate.Recip.Mse <- Stratified.Estimate.Recip.Bias^2+ Stratified.Estimate.Recip.Var
Pooled.Estimate.Recip.Bias <- mean(1/Pooled.Estimate.Results)-True.Theta.Recip
Pooled.Estimate.Recip.Var <- var(1/Pooled.Estimate.Results)
Pooled.Estimate.Recip.Mse <- Pooled.Estimate.Recip.Bias^2+Pooled.Estimate.Recip.Var
Npml.Estimate.Recip.Results <- apply(Npml.Estimate.pp*(1/Npml.Estimate.UU),2,sum)
Npml.Estimate.Recip.Bias <- mean(Npml.Estimate.Recip.Results)-True.Theta.Recip
Npml.Estimate.Recip.Var <- var(Npml.Estimate.Recip.Results)
Npml.Estimate.Recip.Mse <- Npml.Estimate.Recip.Bias^2+Npml.Estimate.Recip.Var
Result.Recip <- list(True.Theta.Recip=round(True.Theta.Recip,places),True.Theta.Recip.Var=round(True.Theta.Recip.Var,places),strat_estimate_recip_bias=round(Stratified.Estimate.Recip.Bias,places), Stratified.Estimate.Recip.Var=round( Stratified.Estimate.Recip.Var,places),Stratified.Estimate.Recip.Mse=round(Stratified.Estimate.Recip.Mse,places),Pooled.Estimate.Recip.Bias=round(Pooled.Estimate.Recip.Bias,places),Pooled.Estimate.Recip.Var=round(Pooled.Estimate.Recip.Var,places),Pooled.Estimate.Recip.Mse=round(Pooled.Estimate.Recip.Mse,places),Npml.Estimate.Recip.Bias=round(Npml.Estimate.Recip.Bias,places),Npml.Estimate.Recip.Var=round(Npml.Estimate.Recip.Var,places),Npml.Estimate.Recip.Mse=round(Npml.Estimate.Recip.Mse,places))
#caculate the logit estimate of the three different methods
#caculate the bias and variance of the logit estimate and get the mse
temp <- (Npml.Estimate.UU==1)
New.Npml.Estimate.UU <- NULL
New.Npml.Estimate.pp <- NULL
for(i in 1:ncol(temp)){
if(sum(temp[,i]==F)==K){
New.Npml.Estimate.UU <- cbind(New.Npml.Estimate.UU,Npml.Estimate.UU[,i])
New.Npml.Estimate.pp <- cbind(New.Npml.Estimate.pp,Npml.Estimate.pp[,i])
}
}
Stratified.Estimate.Logit.Bias <- mean(logit(Stratified.Estimate.Results))-True.Theta.Logit
Stratified.Estimate.Logit.Var <- var(logit(Stratified.Estimate.Results))
Stratified.Estimate.Logit.Mse <- Stratified.Estimate.Logit.Bias^2+Stratified.Estimate.Logit.Var
Pooled.Estimate.Logit.Bias <- mean(logit(Pooled.Estimate.Results))-True.Theta.Logit
Pooled.Estimate.Logit.Var <- var(logit(Pooled.Estimate.Results))
Pooled.Estimate.Logit.Mse <- Pooled.Estimate.Logit.Bias^2+Pooled.Estimate.Logit.Var
Npml.Estimate.Logit.Results <- apply(New.Npml.Estimate.pp*(logit(New.Npml.Estimate.UU)),2,sum)
Npml.Estimate.Logit.Bias <- mean(Npml.Estimate.Logit.Results)-True.Theta.Logit
Npml.Estimate.Logit.Var <- var(Npml.Estimate.Logit.Results)
Npml.Estimate.Logit.Mse <- Npml.Estimate.Logit.Bias^2+Npml.Estimate.Logit.Var
Result.Logit <- list(True.Theta.Logit=round(True.Theta.Logit,places),True.Theta.Logit.Var=round(True.Theta.Logit.Var,places),strat_estimate_logit_bias=round(Stratified.Estimate.Logit.Bias,places),Stratified.Estimate.Logit.Var=round(Stratified.Estimate.Logit.Var,places),Stratified.Estimate.Logit.Mse=round(Stratified.Estimate.Logit.Mse,places),Pooled.Estimate.Logit.Bias=round(Pooled.Estimate.Logit.Bias,places),Pooled.Estimate.Logit.Var=round(Pooled.Estimate.Logit.Var,places),Pooled.Estimate.Logit.Mse=round(Pooled.Estimate.Logit.Mse,places),Npml.Estimate.Logit.Bias=round(Npml.Estimate.Logit.Bias,places),Npml.Estimate.Logit.Var=round(Npml.Estimate.Logit.Var,places),Npml.Estimate.Logit.Mse=round(Npml.Estimate.Logit.Mse,places))
#build a data frame for the result
assign(paste("result_",Theta.Bar,"_",M,"_",K,"_list",sep=""),list(Result.Mean,Result.Recip,Result.Logit))
assign(paste("result"),list(Result.Mean,Result.Recip,Result.Logit))
method <- c("E(P)","Bias","Var","MSE","E(1/P)","Bias","Var","MSE","E(logit(P))","Bias","Var","MSE")
strat <- c(NA,as.numeric(result[[1]][3]),as.numeric(result[[1]][4]),as.numeric(result[[1]][5]),NA,as.numeric(result[[2]][3]),as.numeric(result[[2]][4]),as.numeric(result[[2]][5]),NA,as.numeric(result[[3]][3]),as.numeric(result[[3]][4]),as.numeric(result[[3]][5]))
pooled <- c(NA,as.numeric(result[[1]][6]),as.numeric(result[[1]][7]),as.numeric(result[[1]][8]),NA,as.numeric(result[[2]][6]),as.numeric(result[[2]][7]),as.numeric(result[[2]][8]),NA,as.numeric(result[[3]][6]),as.numeric(result[[3]][7]),as.numeric(result[[3]][8]))
npml <- c(NA,as.numeric(result[[1]][9]),as.numeric(result[[1]][10]),as.numeric(result[[1]][11]),NA,as.numeric(result[[2]][9]),as.numeric(result[[2]][10]),as.numeric(result[[2]][11]),NA,as.numeric(result[[3]][9]),as.numeric(result[[3]][10]),as.numeric(result[[3]][11]))
True.Value <- c("E","Var")
P <- c(as.numeric(result[[1]][1]),as.numeric(result[[1]][2]))
Recip.P <- c(as.numeric(result[[2]][1]),as.numeric(result[[2]][2]))
Logit.P <- c(as.numeric(result[[3]][1]),as.numeric(result[[3]][2]))
assign(paste("result_",Theta.Bar,"_",M,"_",K,sep=""),data.frame(method,strat,pooled,npml))
assign(paste("true_",Theta.Bar,"_",M,"_",K,sep=""),data.frame(True.Value,P,Recip.P,Logit.P))
objectname <- c(paste("result_",Theta.Bar,"_",M,"_",K,sep=""),paste("true_",Theta.Bar,"_",M,"_",K,sep=""))
Para.Beta.Estimate.Bias <- mean(Para.Beta.Estimate.Result)-True.Theta.Mean
Para.Beta.Estimate.Var <- var(Para.Beta.Estimate.Result)
Para.Beta.Estimate.mse <- Para.Beta.Estimate.Bias^2+ Para.Beta.Estimate.Var
assign(paste("Para.Beta.Result_",Theta.Bar,"_",M,"_",K,sep=""),list(bias=round(Para.Beta.Estimate.Bias,places),var=round(Para.Beta.Estimate.Var,places),mse=round(Para.Beta.Estimate.mse,places)))
print(c(i1,i2,i3))
}
}
}
NTL
N=NTL[1,]
N
ParaBetaEstimateFunction(N)
BetaGeometricLikehood <- function(ThetaBar.Par,M.Par){
alpha <- ThetaBar.Par*M.Par
beta <- M.Par*(1-ThetaBar.Par)
result <- log(alpha)+lgamma(alpha+beta)+lgamma(beta+N-1)-lgamma(beta)-lgamma(alpha+beta+N)
return(-sum(result))
}
ParaBetaEstimateFunction <- function(N){
fit <-  mle2(BetaGeometricLikehood,start = list(ThetaBar.Par=True.Theta.Mean,M.Par =M),method="L-BFGS-B")
coef(fit)[[1]]
return(coef(fit)[[1]])
}
ParaBetaEstimateFunction(N)
ParaBetaEstimateFunction <- function(N){
fit <-  mle2(BetaGeometricLikehood,start = list(ThetaBar.Par=True.Theta.Mean,M.Par =M),lower=c(0.005,0.05),upper=c(0.5,10000),method="L-BFGS-B")
coef(fit)[[1]]
return(coef(fit)[[1]])
}
ParaBetaEstimateFunction(N)
?mle2
N=NTL[,2]
ParaBetaEstimateFunction(N)
N=NTL[,3]
ParaBetaEstimateFunction(N)
N=NTL[4,]
n
N
ParaBetaEstimateFunction(N)
BetaGeometricLikehood <- function(ThetaBar.Par,M.Par){
alpha <- ThetaBar.Par*M.Par
beta <- M.Par*(1-ThetaBar.Par)
result <- log(alpha)+lgamma(alpha+beta)+lgamma(beta+N-1)-lgamma(beta)-lgamma(alpha+beta+N)
return(-sum(result))
}
ParaBetaEstimateFunction <- function(N){
fit <-  mle2(BetaGeometricLikehood,start = list(ThetaBar.Par=True.Theta.Mean,M.Par =M),lower=c(ThetaBar.Par=0.005,M.Par=0.05),upper=c(ThetaBar.Par=0.5,M.Par= 10000),method="L-BFGS-B")
coef(fit)[[1]]
return(coef(fit)[[1]])
}
N=NTL[1,]
n
n
N
ParaBetaEstimateFunction(N)
N=NTL[1,]
ParaBetaEstimateFunction(N)
N=NTL[1,]
ParaBetaEstimateFunction(N)
N=NTL[2,]
ParaBetaEstimateFunction(N)
N=NTL[3,]
ParaBetaEstimateFunction(N)
N=NTL[4,]
ParaBetaEstimateFunction(N)
ParaBetaEstimateFunction <- function(N){
fit <-  mle2(BetaGeometricLikehood,start = list(ThetaBar.Par=True.Theta.Mean,M.Par =M),lower=c(0.005,0.05),upper=c(0.5, 10000),method="L-BFGS-B")
coef(fit)[[1]]
return(coef(fit)[[1]])
}
ParaBetaEstimateFunction(N)
N=NTL[3,]
ParaBetaEstimateFunction(N)
29.08-3.72
1232+38.51+70.59
1341、2
1341/2
data1 <- read.csv("./V10/iCOGS_euro_v10_02242017.csv",1)
getwd()
data1 <- read.csv("./V10/iCOGS_euro_v10_05242017.csv",stringsAsFactors = F)
2194.05-1765.51
47900*0.65/12
2594*0.84
10000/12
833*0.15
28600*6.0
600-57
65000/12
65000/24
29116+12677.79+918
29116+12677.79
42712-771.8
42712-28.55-41940
42712+28.55-41940
4076+61.46
41794+918
42711.79+28.55-41940
42711.79+28.55
800.34+41940
42712+772
800.34+41940
800.34+41940-28.55
42711.79+771.8+28.55
155*0.9
155*0.9/2
155*0.9/2*1.2
500*0.483
getwd()
setwd("~/GoogleDrive/breast_cancer_data_analysis")
library(readr)
library(devtools)
library(CompQuadForm)
library(bc2)
library(data.table)
##analysis for Icog
data1 <- fread("./data/iCOGS_euro_v10_10232017.csv",header=T)
data1 <- as.data.frame(data1)
y.pheno.mis1 <- cbind(data1$Behaviour1,data1$ER_status1,data1$PR_status1,data1$HER2_status1,data1$Grade1)
colnames(y.pheno.mis1) = c("Behavior","ER","PR","HER2","Grade")
head(y.pheno.mis1)
y.pheno.complete1 = y.pheno.mis1 %>%
filter(Behavior==1) %>%
filter(ER!=888&PR!=888&HER2!=888) %>%
select(ER,PR,HER2)
library(dplry)
library(dplyr)
y.pheno.complete1 = y.pheno.mis1 %>%
filter(Behavior==1) %>%
filter(ER!=888&PR!=888&HER2!=888) %>%
select(ER,PR,HER2)
y.pheno.complete1 = as.data.frame(y.pheno.mis1) %>%
filter(Behavior==1) %>%
filter(ER!=888&PR!=888&HER2!=888) %>%
select(ER,PR,HER2)
head(y.pheno.complete1)
apply(y.pheno.complete1,2,table)
cor(y.pheno.complete1)
#x1 and x2 are correlated
Simga <- matrix(c(1,0.5,0.5,1),2,2)
n <- 1000
x <- mvrnorm(n,0,Sigma)
#x1 and x2 are correlated
library(mvtnorm)
x <- mvrnorm(n,0,Sigma)
#x1 and x2 are correlated
library(mvrnorm)
#x1 and x2 are correlated
library(MASS)
Simga <- matrix(c(1,0.5,0.5,1),2,2)
n <- 1000
x <- mvrnorm(n,0,Sigma)
x <- mvrnorm(n,mu = c(0,0),Simga = Sigma)
x <- mvrnorm(n,mu = c(0,0),Sigma = Sigma)
Sigma <- matrix(c(1,0.5,0.5,1),2,2)
n <- 1000
x <- mvrnorm(n,mu = c(0,0),Sigma = Sigma)
head(x)
cor(x)
x1 = x[,1]
x2 = x[,2]
y = x1*0.5+x2*0.5+rnorm(n)
lm(y~x1+x2)
summay(lm(y~x1+x2))
summary(lm(y~x1+x2))
model <- lm(y~x1)
summary(model)
coefficients(model)
p = 1000
beta_est <- rep(0,p)
coefficients(model)[2]
p = 1000
beta_est <- rep(0,p)
for(i in 1:p){
Sigma <- matrix(c(1,0.5,0.5,1),2,2)
n <- 2000
x <- mvrnorm(n,mu = c(0,0),Sigma = Sigma)
x1 = x[,1]
x2 = x[,2]
y = x1*0.5+x2*0.5+rnorm(n)
model <- lm(y~x1)
beta_est[i] <- coefficients(model)[2]
}
beta_est
mean(beta_est)
crossprod(x1,x2)
crossprod(x1,x2)/n
0.5*crossprod(x1,x2)/n
var(beta_est)
0.5*0.5*0.5*0.5+1-0.5^2
(0.5*0.5*0.5*0.5+1-0.5^2)/1000
(0.5*0.5*0.5*0.5+1)/1000
(0.5*0.5*0.5*0.5+1)/2000
library(devtools)
install_github("andrewhaoyu/bc2")
install_github("andrewhaoyu/bc2")
idx.icog.only = which((!is.na(data$SNP.ICOGS))&(!is.na(data$var_name))&is.na(data$SNP.ONCO))
num.of.tumor <- ncol(y.pheno.mis2)-1
load("/spin1/users/zhangh24/breast_cancer_data_analysis/whole_genome/ICOG/ERPRHER2GRADE_fixed_baseline/result/icog_info.Rdata")
get_cor_95 <- function(correlation.matrix,correlation.matrix.se){
correlation.matrix.transform <- 0.5*log((1+correlation.matrix)/(1-correlation.matrix))
correlation.matrix.se.transform <- abs(correlation.matrix.se/((1+correlation.matrix)*(1-correlation.matrix)))
correlation.matrix.transform.low <- correlation.matrix.transform-1.96*correlation.matrix.se.transform
correlation.matrix.transform.high <- correlation.matrix.transform+1.96*correlation.matrix.se.transform
correlation.matrix.low <- (exp(2*correlation.matrix.transform.low)-1)/(exp(2*correlation.matrix.transform.low)+1)
correlation.matrix.high <- (exp(2*correlation.matrix.transform.high)-1)/(exp(2*correlation.matrix.transform.high)+1)
(exp(2*correlation.matrix.transform)-1)/(exp(2*correlation.matrix.transform)+1)
correlation.matrix <- round(correlation.matrix,places)
correlation.matrix.low <- round(correlation.matrix.low,places)
correlation.matrix.high <- round(correlation.matrix.high,places)
M <- nrow(correlation.matrix)
correlation.matrix.new <- rep("c",M^2)
temp <- 1
for(i in 1:M){
for(j in 1:M){
correlation.matrix.new[temp] <- paste0(correlation.matrix[i,j]," (",correlation.matrix.low[i,j],"-",correlation.matrix.high[i,j],")")
temp <- temp+1
}
}
correlation.matrix.new <- matrix(correlation.matrix.new,M,M)
return(correlation.matrix.new)
}
get_cor_95_list <- function(correlation.matrix,correlation.matrix.se){
correlation.matrix.transform <- 0.5*log((1+correlation.matrix)/(1-correlation.matrix))
correlation.matrix.se.transform <- abs(correlation.matrix.se/((1+correlation.matrix)*(1-correlation.matrix)))
correlation.matrix.transform.low <- correlation.matrix.transform-1.96*correlation.matrix.se.transform
correlation.matrix.transform.high <- correlation.matrix.transform+1.96*correlation.matrix.se.transform
correlation.matrix.low <- (exp(2*correlation.matrix.transform.low)-1)/(exp(2*correlation.matrix.transform.low)+1)
correlation.matrix.high <- (exp(2*correlation.matrix.transform.high)-1)/(exp(2*correlation.matrix.transform.high)+1)
diag(correlation.matrix.se.transform) = 0.1
diag(correlation.matrix.transform) = 1000
correlation.matrix.se.transform = as.matrix(correlation.matrix.se.transform)
correlation.matrix.transform = as.matrix(correlation.matrix.transform)
p.value = 2*pnorm(abs(correlation.matrix.transform/correlation.matrix.se.transform),lower.tail = F)
return(list(correlation.matrix.low, correlation.matrix.high,p.value))
}
setwd('/Users/zhangh24/GoogleDrive/breast_cancer_data_analysis')
# load("./breast_cancer_ldsc/ICOG_ldsc_result.rda")
# load("./breast_cancer_ldsc/ONCO_ldsc_result.rda")
#load("./breast_cancer_ldsc/two-stage-model-intrinsic_subtype/meta_ldsc_result.rda")
#
#
#
##################only based on BCAC
places <- 3
load("./genetic_correlation/result/ldsc_result_meta+082919.rda")
load("./genetic_correlation/result/ldsc_result_meta_082919.rda")
correlation.matrix <- ldsc_result[[2]]
correlation.matrix.se <- ldsc_result[[4]]
correlation.matrix <- correlation.matrix[c(2,5,4,3,1,6),c(2,5,4,3,1,6)]
ldsc_result[[2]]
correlation.matrix <- correlation.matrix[c(2,5,4,3,1,6),c(2,5,4,3,1,6)]
correlation.matrix.se <- correlation.matrix.se[c(2,5,4,3,1,6),c(2,5,4,3,1,6)]
correlation.95 <- get_cor_95(correlation.matrix,correlation.matrix.se)
names <- colnames(ldsc_result[[2]])[c(2,5,4,3,1,6)]
colnames(correlation.matrix) <- names
rownames(correlation.matrix) <- names
colnames(correlation.95) <- names
rownames(correlation.95) <- names
correlation.matrix.low <- get_cor_95_list(correlation.matrix,correlation.matrix.se)[[1]]
correlation.matrix.high<- get_cor_95_list(correlation.matrix,correlation.matrix.se)[[2]]
correlation.95
write.csv(correlation.95,file="./genetic_correlation/result/correlation_95_BCAC_CIMBA_082919.csv",quote=F)
ldsc_result
diag(ldsc_result[[1]])
correlation.95
load(paste0("/spin1/users/zhangh24/breast_cancer_data_analysis/whole_genome_age/ICOG/ERPRHER2GRADE_fixed_baseline/result/meta_result_shared_1p.Rdata"))
library(dplyr)
?left_join
discovery_snp
?left_join
library(dplry)
library(dplyr)
?left_join
onco_infor
72000+6501+1624
58383*80125/(80125+58383)
bcac_result <- standard_result %>% mutate(
z = log.odds/sqrt(sigma),
or = exp(log.odds),
se = sqrt(sigma),
sample_size = 1/(sigma*2*exp_freq_a1*(1-exp_freq_a1))) %>%
select(snp.id,CHR,position,Effect.Onco,Baseline.Onco,or,se,p.value,
info,
exp_freq_a1)
get_cor_95 <- function(correlation.matrix,correlation.matrix.se){
correlation.matrix.transform <- 0.5*log((1+correlation.matrix)/(1-correlation.matrix))
correlation.matrix.se.transform <- abs(correlation.matrix.se/((1+correlation.matrix)*(1-correlation.matrix)))
correlation.matrix.transform.low <- correlation.matrix.transform-1.96*correlation.matrix.se.transform
correlation.matrix.transform.high <- correlation.matrix.transform+1.96*correlation.matrix.se.transform
correlation.matrix.low <- (exp(2*correlation.matrix.transform.low)-1)/(exp(2*correlation.matrix.transform.low)+1)
correlation.matrix.high <- (exp(2*correlation.matrix.transform.high)-1)/(exp(2*correlation.matrix.transform.high)+1)
(exp(2*correlation.matrix.transform)-1)/(exp(2*correlation.matrix.transform)+1)
correlation.matrix <- round(correlation.matrix,places)
correlation.matrix.low <- round(correlation.matrix.low,places)
correlation.matrix.high <- round(correlation.matrix.high,places)
M <- nrow(correlation.matrix)
correlation.matrix.new <- rep("c",M^2)
temp <- 1
for(i in 1:M){
for(j in 1:M){
correlation.matrix.new[temp] <- paste0(correlation.matrix[i,j]," (",correlation.matrix.low[i,j],"-",correlation.matrix.high[i,j],")")
temp <- temp+1
}
}
correlation.matrix.new <- matrix(correlation.matrix.new,M,M)
return(correlation.matrix.new)
}
get_cor_se <- function(correlation.matrix,correlation.matrix.se){
correlation.matrix <- round(correlation.matrix,places)
correlation.matrix.se <- round(correlation.matrix,places)
M <- nrow(correlation.matrix)
correlation.matrix.new <- rep("c",M^2)
temp <- 1
for(i in 1:M){
for(j in 1:M){
correlation.matrix.new[temp] <- paste0(correlation.matrix[i,j]," (",correlation.matrix.se[i,j],")")
temp <- temp+1
}
}
correlation.matrix.new <- matrix(correlation.matrix.new,M,M)
return(correlation.matrix.new)
}
get_cor_95_list <- function(correlation.matrix,correlation.matrix.se){
correlation.matrix.transform <- 0.5*log((1+correlation.matrix)/(1-correlation.matrix))
correlation.matrix.se.transform <- abs(correlation.matrix.se/((1+correlation.matrix)*(1-correlation.matrix)))
correlation.matrix.transform.low <- correlation.matrix.transform-1.96*correlation.matrix.se.transform
correlation.matrix.transform.high <- correlation.matrix.transform+1.96*correlation.matrix.se.transform
correlation.matrix.low <- (exp(2*correlation.matrix.transform.low)-1)/(exp(2*correlation.matrix.transform.low)+1)
correlation.matrix.high <- (exp(2*correlation.matrix.transform.high)-1)/(exp(2*correlation.matrix.transform.high)+1)
diag(correlation.matrix.se.transform) = 0.1
diag(correlation.matrix.transform) = 1000
correlation.matrix.se.transform = as.matrix(correlation.matrix.se.transform)
correlation.matrix.transform = as.matrix(correlation.matrix.transform)
p.value = 2*pnorm(abs(correlation.matrix.transform/correlation.matrix.se.transform),lower.tail = F)
return(list(correlation.matrix.low, correlation.matrix.high,p.value))
}
setwd('/Users/zhangh24/GoogleDrive/breast_cancer_data_analysis')
# load("./breast_cancer_ldsc/ICOG_ldsc_result.rda")
# load("./breast_cancer_ldsc/ONCO_ldsc_result.rda")
#load("./breast_cancer_ldsc/two-stage-model-intrinsic_subtype/meta_ldsc_result.rda")
#
#
#
##################only based on BCAC
places <- 2
load("./genetic_correlation/result/ldsc_result_meta_082919.rda")
diag(ldsc_result[[1]][c(2,5,4,3,1,6),c(2,5,4,3,1,6)])
ldsc_result[[1]]
ldsc_result[[2]]
ldsc_result[[3]]
diag(ldsc_result[[3]][c(2,5,4,3,1,6),c(2,5,4,3,1,6)])
diag(ldsc_result[[4]][c(2,5,4,3,1,6),c(2,5,4,3,1,6)])
round(diag(ldsc_result[[4]][c(2,5,4,3,1,6),c(2,5,4,3,1,6)]),2)
round(diag(ldsc_result[[4]][c(2,5,4,3,1,6),c(2,5,4,3,1,6)]),2)
round(0.034,2)
diag(ldsc_result[[3]][c(2,5,4,3,1,6),c(2,5,4,3,1,6)])
round(diag(ldsc_result[[3]][c(2,5,4,3,1,6),c(2,5,4,3,1,6)]),2)
round(diag(ldsc_result[[3]][c(2,5,4,3,1,6),c(2,5,4,3,1,6)]),3)
i1 = 1
2*log(2)*0.41
(61282*45494)/(45494+61282)
icog_infor_s
?median
-0.018
0.01048
0.01021
0.01591
-0.0114
0.0203
var_meta = 1/(1/0.01048^2+1/0.01591^2+1/0.0203^2)
beta_meta = var_meta*(-0.018/0.01048^2+0.01021/0.01591^2+-0.0114/0.0203^2)
beta_meta
sqrt(var_meta)
122977*105974/(122977+105974)
second.num.s
2*log(2)*0.41
2*log(2)*0.40
