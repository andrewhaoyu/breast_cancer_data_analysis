estlambda(pex, method="KS")
a <- qtscore(bt,srdta)
lambda(a)
install.pakcages("GenABEL")
install.package("GenABEL")
install.packages("GenABEL")
library(dplry)
new.chr.pos = new_discovery_snp %>%
mutate(paste0(CHR,":",Pos))
48+36.2-25.2+12.9-5.4x1.6x1.6
48+36.2-25.2+12.9-5.4x1.6x1.6
48+36.2-25.2+12.9-5.4*1.6*1.6
getwd()
#-------------------------------------------------------------------
# Update Date: 12/10/2018
# Goal: merge discovery additive and intrinsic results together
# Author: Haoyu Zhang
#-------------------------------------------------------------------
#---------------------------------------#---------------------------------------
additive <- read.csv("./discovery_SNP/additive_model/result/additive_model_final.csv ")
#-------------------------------------------------------------------
# Update Date: 12/10/2018
# Goal: merge discovery additive and intrinsic results together
# Author: Haoyu Zhang
#-------------------------------------------------------------------
#---------------------------------------#---------------------------------------
additive <- read.csv("./discovery_SNP/additive_model/result/additive_model_final.csv")
additive
intrinsic <- read.csv("./discovery_SNP/additive_model/result/intrinsic_subtype_final.csv")
intrinsic
colnames(additive)[1] <- "rs_id"
library(drplyr)
library(dplyr)
combind <- left_join(additive,intrinsic)
dim(additive)
dim(intrinsic)
#-------------------------------------------------------------------
# Update Date: 12/10/2018
# Goal: merge discovery additive and intrinsic results together
# Author: Haoyu Zhang
#-------------------------------------------------------------------
#---------------------------------------#---------------------------------------
additive <- read.csv("./discovery_SNP/additive_model/result/additive_model_final.csv")
intrinsic <- read.csv("./discovery_SNP/additive_model/result/intrinsic_subtype_final.csv")
colnames(additive)[1] <- "rs_id"
library(dplyr)
combind <- left_join(additive,intrinsic)
combind
write.csv(combind,file= "./discovery_SNP/additive_model/result/discovery_snp_summary_121118.csv")
combind.2 <- combind[1:15,]
combind.2
colnames(combind.2)
combind.2[,c(21,23,25,27,29)]
combind.2.p <- combind.2[,c(21,23,25,27,29)]
combind.2.p
apply(combind.2.p,1,min)
apply(combind.2.p,1,which.min)
z.design <- z.design[,c(1,4,5)]
setwd("/spin1/users/zhangh24/breast_cancer_data_analysis/")
setwd("/spin1/users/zhangh24/breast_cancer_data_analysis/")
library(readr)
library(devtools)
library(CompQuadForm)
library(bc2)
setwd("/spin1/users/zhangh24/breast_cancer_data_analysis/")
library(readr)
library(devtools)
library(CompQuadForm)
library(bc2)
178+32
x.snp.all.train2
2*log(2)
###convert the result to log odds ratio
subsplit("0.9353(0.91111-0.96012)","(")
as.matrix(result[,c(2*(1:n.subtypes))])
?glm
n <- 100
x1 = rnorm(n)
x2 = rnorm(n)
logit_inv <- function(x){
exp(x)/(1+exp(x))
}
p = logit_inv(1+x1*2+x2*1)
y = rbinom(1,1,p)
y
y = rbinom(n,1,p)
y
?rbinom
y
p <- c(rep(1,50),rep(0,50))
rbinom(n,1,p)
library(ggplot2)
data <- data.frame(y=y,x1=x1,x2=x2)
ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))
model <- glm(y~x1+x2,family=binomial)
summary(model)
summary(model)$coefficient
beta <- summary(model)$coefficient[2:3,1]
beta
beta <- summary(model)$coefficient[2:3,1]
ab <- function(beta){
a = -1/beta[2]
b = -beta1/beta2
return(c(a,b))
}
ab_fun <- function(beta){
a = -1/beta[2]
b = -beta1/beta2
return(c(a,b))
}
ab <- ab_fun(beta)
ab_fun <- function(beta){
a = -1/beta[2]
b = -beta[1]/beta[2]
return(c(a,b))
}
ab <- ab_fun(beta)
ab
ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1]
slope = ab[2])
ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
ab_fun <- function(beta){
a = -beta[1]/beta[2]
b = -beta[2]/beta[3]
return(c(a,b))
}
ab <- ab_fun(beta)
ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
ab
beta
beta <- summary(model)$coefficient[,1]
beta
ab_fun <- function(beta){
a = -beta[1]/beta[2]
b = -beta[2]/beta[3]
return(c(a,b))
}
ab <- ab_fun(beta)
ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
x  = cbind(1,x1,x2)
Sys.sleep(1)
print(1)
Sys.sleep(1)
print(1)
theta_old = c(0,1,1)
x  = cbind(1,x1,x2)
n.up = 100
alpha = 1/n
for(i in 1:n.up){
print(i)
ab <- ab_fun(theta_old)
ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
theta_new = theta_old + alpha*t(x)%*%(y-logit_inv(x%*%theta_old))
error = max(abs(theta_new-theta_old))
if(error<1/n){
break
}
theta_old = theta_new
print(theta_new)
Sys.sleep(1)
}
beta <- summary(model)$coefficient[,1]
beta
ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
ab
ab <- ab_fun(beta)
ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
n.up = 100
alpha = 0.1
for(i in 1:n.up){
print(i)
ab <- ab_fun(theta_old)
ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
theta_new = theta_old + alpha*t(x)%*%(y-logit_inv(x%*%theta_old))
error = max(abs(theta_new-theta_old))
if(error<1/(10*n)){
break
}
theta_old = theta_new
print(theta_new)
Sys.sleep(1)
}
beta
theta_old = c(0,1,1)
x  = cbind(1,x1,x2)
#############gradient descent
n.up = 100
alpha = 0.1
print(i)
ab <- ab_fun(theta_old)
p1 = ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
print(p1)
theta_old = c(0,1,1)
x  = cbind(1,x1,x2)
#############gradient descent
n.up = 100
alpha = 0.1
for(i in 1:n.up){
print(i)
ab <- ab_fun(theta_old)
p1 = ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
print(p1)
theta_new = theta_old + alpha*t(x)%*%(y-logit_inv(x%*%theta_old))
error = max(abs(theta_new-theta_old))
if(error<1/(10*n)){
break
}
theta_old = theta_new
print(theta_new)
Sys.sleep(2)
}
theta_old = c(0,1,1)
x  = cbind(1,x1,x2)
#############fisher scoring
n.up = 100
alpha = 0.1
x[1,]%*%t(x[1,])
crossprod(t(x[1,]),x[1,])
#save matrix x_i * x_i^t
#save as a list
result <- list()
#save matrix x_i * x_i^t
#save as a list
x_result <- list()
for(i in 1:n){
x_result[[i]] <- crossprod(t(x[i,]),x[i,])
}
theta_old = c(0,1,1)
x  = cbind(1,x1,x2)
#############fisher scoring
n.up = 100
alpha = 0.1
#save matrix x_i * x_i^t
#save as a list
x_result <- list()
for(i in 1:n){
x_result[[i]] <- crossprod(t(x[i,]),x[i,])
}
infor_fun <- function(x_list,w_vec,p){
infor <- matrix(0,p,p)
for(i in 1:length(w_vec)){
infor <- infor + w_vec[i]*x_result[[i]]
}
return(infor)
}
for(i in 1:n.up){
print(i)
ab <- ab_fun(theta_old)
p1 = ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
mu = logit_inv(x%*%theta_old)
w = mu*(1-mu)
x
infor <- infor_fun(x_list,w_vec,p)
theta_new = theta_old + solve*t(x)%*%(y-mu)
error = max(abs(theta_new-theta_old))
if(error<1/(10*n)){
break
}
theta_old = theta_new
print(theta_new)
Sys.sleep(1)
}
for(i in 1:n.up){
print(i)
ab <- ab_fun(theta_old)
p1 = ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
mu = logit_inv(x%*%theta_old)
w = mu*(1-mu)
infor <- infor_fun(x_list,w,p)
theta_new = theta_old + solve*t(x)%*%(y-mu)
error = max(abs(theta_new-theta_old))
if(error<1/(10*n)){
break
}
theta_old = theta_new
print(theta_new)
Sys.sleep(1)
}
x_result[[i]]
w
w[1]*x_list[[1]]
infor_fun <- function(x_list,w_vec,p){
infor <- matrix(0,p,p)
for(i in 1:length(w_vec)){
infor <- infor + w_vec[i]*x_list[[i]]
}
return(infor)
}
for(i in 1:n.up){
print(i)
ab <- ab_fun(theta_old)
p1 = ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
mu = logit_inv(x%*%theta_old)
w = mu*(1-mu)
infor <- infor_fun(x_list,w,p)
theta_new = theta_old + solve*t(x)%*%(y-mu)
error = max(abs(theta_new-theta_old))
if(error<1/(10*n)){
break
}
theta_old = theta_new
print(theta_new)
Sys.sleep(1)
}
#save matrix x_i * x_i^t
#save as a list
x_list <- list()
for(i in 1:n){
x_list[[i]] <- crossprod(t(x[i,]),x[i,])
}
infor_fun <- function(x_list,w_vec,p){
infor <- matrix(0,p,p)
for(i in 1:length(w_vec)){
infor <- infor + w_vec[i]*x_list[[i]]
}
return(infor)
}
for(i in 1:n.up){
print(i)
ab <- ab_fun(theta_old)
p1 = ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
mu = logit_inv(x%*%theta_old)
w = mu*(1-mu)
infor <- infor_fun(x_list,w,p)
theta_new = theta_old + solve*t(x)%*%(y-mu)
error = max(abs(theta_new-theta_old))
if(error<1/(10*n)){
break
}
theta_old = theta_new
print(theta_new)
Sys.sleep(1)
}
w[i]
w[i]*x_list[[i]]
infor
p
p <- length(theta_old)
for(i in 1:n.up){
print(i)
ab <- ab_fun(theta_old)
p1 = ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
mu = logit_inv(x%*%theta_old)
w = mu*(1-mu)
infor <- infor_fun(x_list,w,p)
theta_new = theta_old + solve*t(x)%*%(y-mu)
error = max(abs(theta_new-theta_old))
if(error<1/(10*n)){
break
}
theta_old = theta_new
print(theta_new)
Sys.sleep(1)
}
p <- length(theta_old)
for(i in 1:n.up){
print(i)
ab <- ab_fun(theta_old)
p1 = ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
mu = logit_inv(x%*%theta_old)
w = mu*(1-mu)
infor <- infor_fun(x_list,w,p)
theta_new = theta_old + solve(infor)%*%t(x)%*%(y-mu)
error = max(abs(theta_new-theta_old))
if(error<1/(10*n)){
break
}
theta_old = theta_new
print(theta_new)
Sys.sleep(1)
}
theta_old = c(0,1,1)
x  = cbind(1,x1,x2)
#############gradient descent
n.up = 100
alpha = 0.1
for(i in 1:n.up){
print(i)
ab <- ab_fun(theta_old)
p1 = ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
#print(p1)
theta_new = theta_old + alpha*t(x)%*%(y-logit_inv(x%*%theta_old))
error = max(abs(theta_new-theta_old))
if(error<1/(10*n)){
break
}
theta_old = theta_new
print(theta_new)
Sys.sleep(2)
}
load(paste0("./discovery_SNP/additive_model/result/intrinsic_subtype_heter_herita",i1,".Rdata"))
result_standard <- matrix(0,35,2)
result_standard
result_standard <- result_standard[idx.match,]
dis.result <- cbind(dis.result,result_standard)
n <- 10
x1 = rnorm(n)
x2 = rnorm(n)
logit_inv <- function(x){
exp(x)/(1+exp(x))
}
p = logit_inv(1+x1*2+x2*1)
y = rbinom(n,1,p)
library(ggplot2)
data <- data.frame(y=y,x1=x1,x2=x2)
model <- glm(y~x1+x2,family=binomial)
beta <- summary(model)$coefficient[,1]
beta
n <- 20
x1 = rnorm(n)
x2 = rnorm(n)
logit_inv <- function(x){
exp(x)/(1+exp(x))
}
p = logit_inv(1+x1*2+x2*1)
y = rbinom(n,1,p)
library(ggplot2)
data <- data.frame(y=y,x1=x1,x2=x2)
model <- glm(y~x1+x2,family=binomial)
beta <- summary(model)$coefficient[,1]
beta
n <- 30
x1 = rnorm(n)
x2 = rnorm(n)
logit_inv <- function(x){
exp(x)/(1+exp(x))
}
p = logit_inv(1+x1*2+x2*1)
y = rbinom(n,1,p)
library(ggplot2)
data <- data.frame(y=y,x1=x1,x2=x2)
model <- glm(y~x1+x2,family=binomial)
beta <- summary(model)$coefficient[,1]
beta
summary(model)$coefficient
0.84254182^2-0.4343026^2
n <- 100
x1 = rnorm(n)
x2 = rnorm(n)
logit_inv <- function(x){
exp(x)/(1+exp(x))
}
p = logit_inv(1+x1*2+x2*1)
y = rbinom(n,1,p)
library(ggplot2)
data <- data.frame(y=y,x1=x1,x2=x2)
model <- glm(y~x1+x2,family=binomial)
beta <- summary(model)$coefficient[,1]
ab_fun <- function(beta){
a = -beta[1]/beta[2]
b = -beta[2]/beta[3]
return(c(a,b))
}
ab <- ab_fun(beta)
ggplot(data,aes(x1,x2)) + geom_point(aes(color = y))+
geom_abline(intercept= ab[1],
slope = ab[2])
predict(model)
beta%*%cbind(x,x1,x2)
beta
cbind(x,x1,x2)%*%beta
cbind(1,x1,x2)%*%beta
y_predict <- ifelse(logit_inv(predict(model))>0.5,1,0)
y_predict
y
error <- mean(sum(y-y_predict)^2)
error
y
y_predict
y-y_predict
error <- mean((y-y_predict)^2)
error
0.32/(2*log(2))
0.568/2
2*log(2)*0.41
qnorm(0.1)
qnorm(0.9)
qnorm(0.975)
(1.96+1.28)^2*(10^2+10^2)
