rbinom(1,2,0.25)
rbinom(10,2,0.25)
rbinom(100,2,0.25)
mean(rbinom(100,2,0.25))
sample(c(1:10),0.1)
?sample
sample(c(1:10),10,prob=0.16)
sample(c(1:10),1,prob=0.16)
sample(c(1:10),size = 1,prob=0.16)
sample(c(1:10),1000)
sample(c(1:10),8)
sample(idx.case,size=length(idx.case)*0.17)
library(qqman)
install.packages("qqman")
library(qqman)
?qq
?plot
install_github("andrewhaoyu/bc2")
apply(odds1,2,mean)
apply(odds1,2,var)
apply(odds2,2,var)
5000*5
25000*5
200000/5000
SQRT(40)
sqrt(40)
5000*6
30000*6
100000/5000
sqrt(20)
5000*4
20000*4
20*50
1000/60
50*1000
240/20
?eigen
48600-13265
35335/48600
1-0.73
48600*0.27
13265/48600
37900*0.35
48600*0.35
48600*0.273
13265/48600
27.29*48600
0.2729*48600
0.2730*48600
35335+13265
list(p_global,p_heter,p_indi,p_mglobal,p_mheter)
score.fixed.heter <- score.test.heter.fixed[[1]]
score.fixed.heter <- score.test.heter.fixed[[1]]
2000*3000*2
exp(0.05)
0.15
exp(0.15)
0.02^2
rnorm(4,0,0.02)
rnorm(4,0,0.02)
rnorm(4,0,0.02)
rnorm(4,0,0.02)
rnorm(4,0,0.02)
rnorm(4,0,0.02)
rnorm(4,0,0.02)
rnorm(4,0,0.02)
10^6
0.05/1000
0.05/10^5
2^5*3
324/19
342/19
(19+32)*19
library(nnet)
?multimom
?multinom
?pchisq
?pchisq
25*10
6*25
6*30
20*25
20*10
20*2
2000/100*2
1000*2000
3000*4000
2000/100*2
5*500
2500/24
5*100
500/60
5*1000
5000/3600
5000/60
?pattern
?dir
data <- read.csv("power_result.csv")
setwd('/Users/zhangh24/GoogleDrive/breast_cancer_data_analysis/simulation/power/result')
data <- read.csv("power_result")
data <- read.csv("power_result.csv")
head(data)
library(ggplot2)
install.packages("ggplot2")
library(ggplot2)
colnames(data)
ggplot(data,aes(x = "Sample.Size",y="Poewr"))+geom_bar()
setwd('/Users/zhangh24/GoogleDrive/breast_cancer_data_analysis/simulation/power/result')
data <- read.csv("power_result.csv")
colnames(data)
library(ggplot2)
head(data)
ggplot(data,aes(x="Sample.Size",y="Power"))+
geom_line(aes(color=Method))
head(data)
idx <- which(data[,2]== "No heterogeneity")
idx
head(data)
idx <- which(data[,2]== "No heterogneity")
idx
data.new <- data[idx,]
ggplot(data.new,aes(x="Sample.Size",y="Power"))+
geom_line(aes(color=Method))
range(data.new$Power)
data.new
data
setwd('/Users/zhangh24/GoogleDrive/breast_cancer_data_analysis/simulation/power/result')
data <- read.csv("power_result.csv")
colnames(data)
library(ggplot2)
idx <- which(data[,2]== "No heterogneity")
data.new <- data[idx,]
ggplot(data.new,aes(x="Sample.Size",y="Power"))+
geom_line(aes(color=Method))
data.new
ggplot(data.new,aes(x="Sample.Size",y="Power",color=Method))+
geom_line()
ggplot(data.new,aes(x="Sample.Size",y="Power",color=Method))+
geom_line()+
ylim(0,1)
ggplot(data.new,aes(x="Sample.Size",y="Power",color=Method))+
geom_line()+
ylim(0,1)
plot(data.new[,3],data.new[,4])
ggplot(data.new,aes(x="Sample.Size",y="Power",color=Method))+
geom_line()+
ylim(0,1)
ggplot(data.new,aes(x="Sample.Size",y="Power",color=Method))+
geom_line()
data.new[,3] <- as.factor(data.new[,3])
ggplot(data.new,aes(x="Sample.Size",y="Power",color=Method))+
geom_line()
data.new <- data[idx,]
ggplot(data.new,aes(x=Sample.Size,y=Power,color=Method))+
geom_line()
data.new[,3] <- as.factor(data.new[,3])
ggplot(data.new,aes(x=Sample.Size,y=Power,color=Method))+
geom_line()
ggplot(data,aes(x=Sample.Size,y=Power,color=Method))+
geom_line()
head(data)
ggplot(data,aes(x=Sample.Size,y=Power,color=Method,
shape = Scenarior ))+
geom_line()
idx <- which(data[,2]== "No heterogneity")
data.new <- data[idx,]
ggplot(data,aes(x=Sample.Size,y=Power,color=Method,
shape = Scenarior ))+
geom_line()
ggplot(data,aes(x=Sample.Size,y=Power,color=Method,
shape = Scenarior ))+
geom_line()+
scale_y_discrete(c(5000,50000,100000))
ggplot(data.new,aes(x=Sample.Size,y=Power,color=Method,
shape = Scenarior ))+
geom_line()+
scale_y_discrete(c(5000,50000,100000))
ggplot(data.new,aes(x=Sample.Size,y=Power,color=Method,
shape = Scenarior ))+
geom_line()+
scale_x_discrete(c(5000,50000,100000))
SimulateDataPower <- function(theta_intercept,theta_test,theta_covar,n){
a <- c(0,1)
b <- c(0,1)
c <- c(0,1)
d <- c(1,2,3)
##number of the other covarites
p_col <- 1
z.standard <- as.matrix(expand.grid(a,b,c,d)) # orig
M <- nrow(z.standard)
#z <- as.matrix(expand.grid(a,b))
#this z_design matrix is the second stage matrix
z.design.additive <- cbind(1,z.standard)
M <- nrow(z.design.additive)
additive.number <- 2
additive.second.cat <- ncol(z.design.additive)
total.covar.number <- 1+ additive.number
z.all <- matrix(0,nrow=(M*total.covar.number),ncol = (M+                                                        additive.second.cat*additive.number))
for(i in c("intercept",
"additive"
)){
##we always keep intercept as saturated model and to simply, we always use diagnonal matrix for intercept
if(i=="intercept"){
###row start and column start point for this category
row.start <- 0
column.start <- 0
for(j in 1:M){
z.all[row.start+1+(j-1)*total.covar.number,(column.start+j)] = 1
}
}else if(i=="additive"){
column.start <- M
row.start <- 1
if(additive.number!=0){
for(j in 1:M){
for(k in 1:additive.number){
z.all[row.start+k+(j-1)*total.covar.number,
(column.start+(k-1)*additive.second.cat+1):
(column.start+k*additive.second.cat)] <- as.matrix(z.design.additive[j,])
}
}
}
}
}
K <- ncol(z.design.additive)
# z <- kronecker(diag(2),z)
#this theta is the true value
theta <- c(theta_intercept,theta_test,theta_covar)
#this is the true beta
beta <- z.all%*%theta
beta <- matrix(beta,nrow=p_col+2)
#alpha <- c(0,rep(1,length(beta)-1))
G <-  rbinom(n,2,0.25)
x_covar <- rnorm(n)
x_all <- cbind(1,G,x_covar) ##adding the intercept into the model
predictor <- x_all%*%(beta)
predictor <- cbind(0,predictor)
#predictor <- sweep(predictor,2,alpha,"+")
p <- exp(predictor)
sp <- rowSums(p)
#this standarize the probability sum into 1,since logit model:pr(D=1|predictor)=exp(predictor)/(1+exp(predictor))
p <- sweep(p,1,sp,"/")
y <- t(apply(p,1,function(x){rmultinom(1,1,x)}))
y <- y[,-1] # this is the y matrix for the model
y.case.control <- rowSums(y)
y.tumor <- y%*%z.standard
idx.control <- which(y.case.control==0)
y.tumor[idx.control,] <- rep(NA,4)
idx.case <- which(y.case.control==1)
rate <- c(0.17,0.25,0.42,0.27)
for(i in 1:4){
idx.mis <-  sample(idx.case,size=length(idx.case)*rate[i])
y.tumor[idx.mis,i] <- 888
}
y.pheno.mis <- cbind(y.case.control,y.tumor)
return(list(y.pheno.mis=y.pheno.mis,
G=G,
x_covar=x_covar))
}
SimulateDataPower <- function(theta_intercept,theta_test,theta_covar,n){
a <- c(0,1)
b <- c(0,1)
c <- c(0,1)
d <- c(1,2,3)
##number of the other covarites
p_col <- 1
z.standard <- as.matrix(expand.grid(a,b,c,d)) # orig
M <- nrow(z.standard)
#z <- as.matrix(expand.grid(a,b))
#this z_design matrix is the second stage matrix
z.design.additive <- cbind(1,z.standard)
M <- nrow(z.design.additive)
additive.number <- 2
additive.second.cat <- ncol(z.design.additive)
total.covar.number <- 1+ additive.number
z.all <- matrix(0,nrow=(M*total.covar.number),ncol = (M+                                                        additive.second.cat*additive.number))
for(i in c("intercept",
"additive"
)){
##we always keep intercept as saturated model and to simply, we always use diagnonal matrix for intercept
if(i=="intercept"){
###row start and column start point for this category
row.start <- 0
column.start <- 0
for(j in 1:M){
z.all[row.start+1+(j-1)*total.covar.number,(column.start+j)] = 1
}
}else if(i=="additive"){
column.start <- M
row.start <- 1
if(additive.number!=0){
for(j in 1:M){
for(k in 1:additive.number){
z.all[row.start+k+(j-1)*total.covar.number,
(column.start+(k-1)*additive.second.cat+1):
(column.start+k*additive.second.cat)] <- as.matrix(z.design.additive[j,])
}
}
}
}
}
K <- ncol(z.design.additive)
# z <- kronecker(diag(2),z)
#this theta is the true value
theta <- c(theta_intercept,theta_test,theta_covar)
#this is the true beta
beta <- z.all%*%theta
beta <- matrix(beta,nrow=p_col+2)
#alpha <- c(0,rep(1,length(beta)-1))
G <-  rbinom(n,2,0.25)
x_covar <- rnorm(n)
x_all <- cbind(1,G,x_covar) ##adding the intercept into the model
predictor <- x_all%*%(beta)
predictor <- cbind(0,predictor)
#predictor <- sweep(predictor,2,alpha,"+")
p <- exp(predictor)
sp <- rowSums(p)
#this standarize the probability sum into 1,since logit model:pr(D=1|predictor)=exp(predictor)/(1+exp(predictor))
p <- sweep(p,1,sp,"/")
y <- t(apply(p,1,function(x){rmultinom(1,1,x)}))
y <- y[,-1] # this is the y matrix for the model
y.case.control <- rowSums(y)
y.tumor <- y%*%z.standard
idx.control <- which(y.case.control==0)
y.tumor[idx.control,] <- rep(NA,4)
idx.case <- which(y.case.control==1)
rate <- c(0.17,0.25,0.42,0.27)
for(i in 1:4){
idx.mis <-  sample(idx.case,size=length(idx.case)*rate[i])
y.tumor[idx.mis,i] <- 888
}
y.pheno.mis <- cbind(y.case.control,y.tumor)
return(list(y.pheno.mis=y.pheno.mis,
G=G,
x_covar=x_covar))
}
library(bc2)
theta_intercept <- c(-6.51, -3.64, -3.71, -3.93, -4.74, -3.43, -4.45, -2.40, -3.60, -5.85,-1.20,-3.50, -4.51, -2.39, -4.46, -3.53, -5.95,-4.00, -3.62,-2.14,-5.14, -2.65, -3.88,-2.91)
theta_covar <- c(0.05,0,0,0,0)
SimulateDataPower <- function(theta_intercept,theta_test,theta_covar,n){
a <- c(0,1)
b <- c(0,1)
c <- c(0,1)
d <- c(1,2,3)
##number of the other covarites
p_col <- 1
z.standard <- as.matrix(expand.grid(a,b,c,d)) # orig
M <- nrow(z.standard)
#z <- as.matrix(expand.grid(a,b))
#this z_design matrix is the second stage matrix
z.design.additive <- cbind(1,z.standard)
M <- nrow(z.design.additive)
additive.number <- 2
additive.second.cat <- ncol(z.design.additive)
total.covar.number <- 1+ additive.number
z.all <- matrix(0,nrow=(M*total.covar.number),ncol = (M+                                                        additive.second.cat*additive.number))
for(i in c("intercept",
"additive"
)){
##we always keep intercept as saturated model and to simply, we always use diagnonal matrix for intercept
if(i=="intercept"){
###row start and column start point for this category
row.start <- 0
column.start <- 0
for(j in 1:M){
z.all[row.start+1+(j-1)*total.covar.number,(column.start+j)] = 1
}
}else if(i=="additive"){
column.start <- M
row.start <- 1
if(additive.number!=0){
for(j in 1:M){
for(k in 1:additive.number){
z.all[row.start+k+(j-1)*total.covar.number,
(column.start+(k-1)*additive.second.cat+1):
(column.start+k*additive.second.cat)] <- as.matrix(z.design.additive[j,])
}
}
}
}
}
K <- ncol(z.design.additive)
# z <- kronecker(diag(2),z)
#this theta is the true value
theta <- c(theta_intercept,theta_test,theta_covar)
#this is the true beta
beta <- z.all%*%theta
beta <- matrix(beta,nrow=p_col+2)
#alpha <- c(0,rep(1,length(beta)-1))
G <-  rbinom(n,2,0.25)
x_covar <- rnorm(n)
x_all <- cbind(1,G,x_covar) ##adding the intercept into the model
predictor <- x_all%*%(beta)
predictor <- cbind(0,predictor)
#predictor <- sweep(predictor,2,alpha,"+")
p <- exp(predictor)
sp <- rowSums(p)
#this standarize the probability sum into 1,since logit model:pr(D=1|predictor)=exp(predictor)/(1+exp(predictor))
p <- sweep(p,1,sp,"/")
y <- t(apply(p,1,function(x){rmultinom(1,1,x)}))
y <- y[,-1] # this is the y matrix for the model
y.case.control <- rowSums(y)
y.tumor <- y%*%z.standard
idx.control <- which(y.case.control==0)
y.tumor[idx.control,] <- rep(NA,4)
idx.case <- which(y.case.control==1)
rate <- c(0.17,0.25,0.42,0.27)
for(i in 1:4){
idx.mis <-  sample(idx.case,size=length(idx.case)*rate[i])
y.tumor[idx.mis,i] <- 888
}
y.pheno.mis <- cbind(y.case.control,y.tumor)
return(list(y.pheno.mis=y.pheno.mis,
G=G,
x_covar=x_covar))
}
library(bc2)
theta_intercept <- c(-6.51, -3.64, -3.71, -3.93, -4.74, -3.43, -4.45, -2.40, -3.60, -5.85,-1.20,-3.50, -4.51, -2.39, -4.46, -3.53, -5.95,-4.00, -3.62,-2.14,-5.14, -2.65, -3.88,-2.91)
theta_covar <- c(0.05,0,0,0,0)
theta_test <- c(0.05,0,0,0,0)
n <- 50000
######SimulateDataPower will simulate data with 4 tumor characteristics
######theta_test is the effect of Gene
######theta_covar is the effect of one other covariate
######n is the sample size
temp.simu <- SimulateDataPower(theta_intercept,theta_test,theta_covar,n)
#######y.pheno.mis is the phenotype file, first column is case control
#######2:5 columns are er, pr, her2,grade
#######G is Gene
#######x_covar is one other covariate
y.pheno.mis <- temp.simu[[1]]
G <- temp.simu[[2]]
x_covar <- temp.simu[[3]]
z.standard <- GenerateZstandard(y.pheno.mis,missingTumorIndicator = 888)
M <- nrow(z.standard)
##########Fixed effect global test for association################
##########Get the support function for fixed effect
#########Fixed effect supports, model fits under global null, G has no effect
score.test.support <- ScoreTestSupport(
y.pheno.mis,
baselineonly = NULL,
additive = as.matrix(x_covar),
pairwise.interaction = NULL,
saturated = NULL,
missingTumorIndicator = 888
)
score.test = ScoreTest(y=y.pheno.mis,
x= G,
second.stage.structure = "additive",
score.test.support=score.test.support,
missingTumorIndicator=888)
######Get the score and information for fixed effect
score = score.test[[1]]
infor = score.test[[2]]
######Get p value for the mixed effect global test for association
p_global = DisplayFixedScoreTestResult(score,infor)
##########Mixed effect global test for association################
##########z.design fixed put the baseline effect and
z.design.fixed <- cbind(rep(1,M),z.standard[,1])
z.design.random <-z.standard[,2:ncol(z.standard)]
#########Fixed effect supports, model fits under global null, G has no effect
score.test.support.fixed <- ScoreTestSupportMixedModel(
y.pheno.mis,
baselineonly = NULL,
additive = as.matrix(x_covar),
pairwise.interaction = NULL,
saturated = NULL,
missingTumorIndicator = 888,
c(theta_intercept,
theta_covar)
)
#######Calculate the score for fixed effect
score.test.fixed<- ScoreTestMixedModel(y=y.pheno.mis,
x=as.matrix(G),
z.design=z.design.fixed,
score.test.support=score.test.support.fixed,
missingTumorIndicator=888
)
######Get the score and information for fixed effect
score.fixed <- score.test.fixed[[1]]
infor.fixed <- score.test.fixed[[2]]
######Random effect supports, model fits under the null that only random effect is 0. G has the fixed effect
score.test.support.random <- ScoreTestSupportMixedModelSelfDesign(
y.pheno.mis,
x.self.design  = G,
z.design = z.design.fixed,
additive =  as.matrix(x_covar),
pairwise.interaction = NULL,
saturated = NULL,
missingTumorIndicator = 888,
delta0 = c(theta_intercept,theta_test[1:ncol(z.design.fixed)],
theta_covar)
)
#####Calculate the score for random effect
score.test.random<- ScoreTestMixedModel(y=y.pheno.mis,
x=as.matrix(G),
z.design=z.design.random,
score.test.support=score.test.support.random,
missingTumorIndicator=888)
######Get the score and information for random effect
score.random <- score.test.random[[1]]
infor.random <- score.test.random[[2]]
######Get p value for the mixed effect global test for association
p_mglobal <- DisplayMixedScoreTestResult(score.fixed,
infor.fixed,
score.random,
infor.random)[1]
1100/2+140
apply(p_global_result,2,function(x){CountTypeOne(x,10^-5)})
apply(p_heter_result,2,function(x){CountTypeOne(x,10^-5)})
apply(p_indi_result,2,function(x){CountTypeOne(x,10^-5)})
apply(p_mglobal_result,2,function(x){CountTypeOne(x,10^-5)})
apply(p_mheter_result,2,function(x){CountTypeOne(x,10^-5)})
